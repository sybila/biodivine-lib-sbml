use phf::phf_map;

pub const ALLOWED_SBASE_ATTRIBUTES: &[&str] = &["id", "name", "sboTerm", "metaid"];
pub const ALLOWED_SBASE_CHILDREN: phf::Map<&str, &[&str]> = phf_map! {};

pub const ALLOWED_ATTRIBUTES: phf::Map<&str, &[&str]> = phf_map! {
    "model"=> ALLOWED_SBASE_ATTRIBUTES,
    "listOfFunctionDefinitions" => ALLOWED_SBASE_ATTRIBUTES,
    "functionDefinition" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfUnitDefinitions" => ALLOWED_SBASE_ATTRIBUTES,
    "unitDefinition" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfUnits" => ALLOWED_SBASE_ATTRIBUTES,
    "unit" => &["id", "name", "sboTerm", "metaid", "kind", "exponent", "scale", "multiplier"],
    "listOfCompartments" => ALLOWED_SBASE_ATTRIBUTES,
    "compartment" => &["id", "name", "sboTerm", "metaid", "spatialDimensions", "size", "units", "constant"],
    "listOfSpecies" => ALLOWED_SBASE_ATTRIBUTES,
    "species" => &["id", "name", "sboTerm", "metaid", "compartment", "initialAmount", "initialConcentration", "substanceUnits", "hasOnlySubstanceUnits", "boundaryCondition", "constant", "conversionFactor"],
    "listOfParameters" => ALLOWED_SBASE_ATTRIBUTES,
    "parameter" => &["id", "name", "sboTerm", "metaid", "value", "units", "constant"],
    "listOfInitialAssignments" => ALLOWED_SBASE_ATTRIBUTES,
    "initialAssignment" =>&["id", "name", "sboTerm", "metaid", "symbol"],
    "listOfRules" => ALLOWED_SBASE_ATTRIBUTES,
    "algebraicRule" => ALLOWED_SBASE_ATTRIBUTES,
    "assignmentRule" => &["id", "name", "sboTerm", "metaid", "variable"],
    "rateRule" => &["id", "name", "sboTerm", "metaid", "variable"],
    "listOfConstraints" => ALLOWED_SBASE_ATTRIBUTES,
    "constraint" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfReactions" => ALLOWED_SBASE_ATTRIBUTES,
    "reaction" => &["id", "name", "sboTerm", "metaid", "reversible", "compartment"],
    "listOfReactants" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfProducts" => ALLOWED_SBASE_ATTRIBUTES,
    "speciesReference" => &["id", "name", "sboTerm", "metaid", "species", "stoichiometry", "constant"],
    "listOfModifiers" => ALLOWED_SBASE_ATTRIBUTES,
    "modifierSpeciesReference" => &["id", "name", "sboTerm", "metaid", "species"],
    "kineticLaw" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfLocalParameters" => ALLOWED_SBASE_ATTRIBUTES,
    "localParameter" => &["id", "name", "sboTerm", "metaid", "value", "units"],
    "listOfEvents" => ALLOWED_SBASE_ATTRIBUTES,
    "event" => &["id", "name", "sboTerm", "metaid", "useValuesFromTrigger"],
    "trigger" => &["id", "name", "sboTerm", "metaid", "initialValue", "persistent"],
    "priority" => ALLOWED_SBASE_ATTRIBUTES,
    "delay" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfEventAssignments" => ALLOWED_SBASE_ATTRIBUTES,
    "eventAssignment" => &["id", "name", "sboTerm", "metaid", "variable"]
};

pub const ALLOWED_CHILDREN: phf::Map<&str, &[&str]> = phf_map! {
    "sbml" => &["model"],
    "model" => &["listOfFunctionDefinitions", "listOfUnitDefinitions", "listOfCompartments", "listOfSpecies", "listOfParameters", "listOfInitialAssignments", "listOfRules", "listOfConstraints", "listOfReactions", "listOfEvents"],
    "listOfFunctionDefinitions" => &["functionDefinition"],
    "functionDefinition" => &["math"],
    "listOfUnitDefinitions" => &["unitDefinition"],
    "unitDefinition" => &["listOfUnits"],
    "listOfUnits" => &["unit"],
    "unit" => &[],
    "listOfCompartments" => &["compartment"],
    "compartment" => &[],
    "listOfSpecies" => &["species"],
    "species" => &[],
    "listOfParameters" => &["parameter"],
    "parameter" => &[],
    "listOfInitialAssignments" => &["initialAssignment"],
    "initialAssignment" => &["math"],
    "listOfRules" => &["algebraicRule", "assignmentRule", "rateRule"],
    "algebraicRule" => &["math"],
    "assignmentRule" => &["math"],
    "rateRule" => &["math"],
    "listOfConstraints" => &["constraint"],
    "constraint" => &["math", "message"],
    "listOfReactions" => &["reaction"],
    "reaction" => &["listOfReactants", "listOfProducts", "listOfModifiers", "kineticLaw"],
    "listOfReactants" => &["speciesReference"],
    "listOfProducts" => &["speciesReference"],
    "speciesReference" => &[],
    "listOfModifiers" => &["modifierSpeciesReference"],
    "modifierSpeciesReference" => &[],
    "kineticLaw" => &["math", "listOfLocalParameters"],
    "listOfLocalParameters" => &["localParameter"],
    "localParameter" => &[],
    "listOfEvents" => &["event"],
    "event" => &["trigger", "priority", "delay", "listOfEventAssignments"],
    "trigger" => &["math"],
    "priority" => &["math"],
    "delay" => &["math"],
    "listOfEventAssignments" => &["eventAssignment"],
    "eventAssignment" => &["math"],
    // partially covers rule 10202
    "math" => &["abs", "and", "annotation", "annotation-xml", "apply", "arccosh", "arccos", "arccoth",
                "arccot", "arccsch", "arccsc", "arcsech", "arcsec", "arcsinh", "arcsin", "arctanh",
                "arctan", "bvar", "ceiling", "ci", "cn", "cosh", "cos", "coth", "cot", "csch", "csc",
                "csymbol", "degree", "divide", "eq", "exponentiale", "exp", "factorial", "false",
                "floor", "geq", "gt", "implies", "infinity", "lambda", "leq", "ln", "logbase", "log",
                "lt", "max", "min", "minus", "neq", "notanumber", "not", "or", "otherwise", "piecewise",
                "piece", "pi", "plus", "power", "quotient", "rem", "root", "sech", "sec", "semantics",
                "sep", "sinh", "sin", "tanh", "tan", "times", "true", "xor"]
};
