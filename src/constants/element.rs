use crate::constants::namespaces::{Namespace, NS_FBC, NS_LAYOUT, NS_SBML_CORE};
use phf::{phf_map, Map};

macro_rules! extended_sbase_attributes {
    ($($y:expr),*) => {
        &["id", "name", "sboTerm", "metaid", $($y),*]
    };
}

macro_rules! extended_sbase_children {
    ($($y:expr),*) => {
        &["notes", "annotation", $($y),*]
    };
}
pub const ALLOWED_SBASE_ATTRIBUTES: &[&str] = extended_sbase_attributes!();
pub const ALLOWED_SBASE_CHILDREN: &[&str] = extended_sbase_children!();

pub const ALLOWED_ATTRIBUTES: Map<&str, &[&str]> = phf_map! {
    "sbml" => extended_sbase_attributes!("xmlns", "level", "version"),
    "model"=> extended_sbase_attributes!("substanceUnits", "timeUnits", "volumeUnits", "areaUnits", "lengthUnits", "extentUnits", "conversionFactor", "fbc:strict"),
    "listOfFunctionDefinitions" => ALLOWED_SBASE_ATTRIBUTES,
    "functionDefinition" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfUnitDefinitions" => ALLOWED_SBASE_ATTRIBUTES,
    "unitDefinition" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfUnits" => ALLOWED_SBASE_ATTRIBUTES,
    "unit" => extended_sbase_attributes!("kind", "exponent", "scale", "multiplier"),
    "listOfCompartments" => ALLOWED_SBASE_ATTRIBUTES,
    "compartment" => extended_sbase_attributes!("spatialDimensions", "size", "units", "constant"),
    "listOfSpecies" => ALLOWED_SBASE_ATTRIBUTES,
    "species" => extended_sbase_attributes!("compartment", "initialAmount", "initialConcentration", "substanceUnits", "hasOnlySubstanceUnits", "boundaryCondition", "constant", "conversionFactor", "fbc:charge", "fbc:chemicalFormula"),
    "listOfParameters" => ALLOWED_SBASE_ATTRIBUTES,
    "parameter" => extended_sbase_attributes!("value", "units", "constant"),
    "listOfInitialAssignments" => ALLOWED_SBASE_ATTRIBUTES,
    "initialAssignment" => extended_sbase_attributes!("symbol"),
    "listOfRules" => ALLOWED_SBASE_ATTRIBUTES,
    "algebraicRule" => ALLOWED_SBASE_ATTRIBUTES,
    "assignmentRule" => extended_sbase_attributes!("variable"),
    "rateRule" => extended_sbase_attributes!("variable"),
    "listOfConstraints" => ALLOWED_SBASE_ATTRIBUTES,
    "constraint" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfReactions" => ALLOWED_SBASE_ATTRIBUTES,
    "reaction" => extended_sbase_attributes!("reversible", "compartment", "fbc:lowerFluxBound", "fbc:upperFluxBound"),
    "listOfReactants" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfProducts" => ALLOWED_SBASE_ATTRIBUTES,
    "speciesReference" => extended_sbase_attributes!("species", "stoichiometry", "constant"),
    "listOfModifiers" => ALLOWED_SBASE_ATTRIBUTES,
    "modifierSpeciesReference" => extended_sbase_attributes!("species"),
    "kineticLaw" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfLocalParameters" => ALLOWED_SBASE_ATTRIBUTES,
    "localParameter" => extended_sbase_attributes!("value", "units"),
    "listOfEvents" => ALLOWED_SBASE_ATTRIBUTES,
    "event" => extended_sbase_attributes!("useValuesFromTriggerTime"),
    "trigger" => extended_sbase_attributes!("initialValue", "persistent"),
    "priority" => ALLOWED_SBASE_ATTRIBUTES,
    "delay" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfEventAssignments" => ALLOWED_SBASE_ATTRIBUTES,
    "eventAssignment" => extended_sbase_attributes!("variable"),
    // layout package
    "layout" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfLayouts" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfCompartmentGlyphs" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfSpeciesGlyphs" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfReactionGlyphs" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfAdditionalGraphicalObjects" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfTextGlyphs" => ALLOWED_SBASE_ATTRIBUTES,
    "graphicalObject" => extended_sbase_attributes!("layout:metaidRef"),
    "compartmentGlyph" => extended_sbase_attributes!("layout:metaidRef", "layout:compartment", "layout:order"),
    "speciesGlyph" => extended_sbase_attributes!("layout:metaidRef", "layout:species"),
    "reactionGlyph" => extended_sbase_attributes!("layout:metaidRef", "layout:reaction"),
    "listOfSpeciesReferenceGlyphs" => ALLOWED_SBASE_ATTRIBUTES,
    "generalGlyph" => extended_sbase_attributes!("layout:metaidRef", "layout:reference"),
    "listOfReferenceGlyphs" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfSubGlyphs" => ALLOWED_SBASE_ATTRIBUTES,
    "textGlyph" => extended_sbase_attributes!("layout:metaidRef", "layout:graphicalObject", "layout:text", "layout:originText"),
    "speciesReferenceGlyph" => extended_sbase_attributes!("layout:speciesGlyph", "layout:metaidRef", "layout:speciesReference", "layout:role"),
    "referenceGlyph" => extended_sbase_attributes!("layout:glyph", "layout:metaidRef", "layout:reference", "role"),
    "position" => extended_sbase_attributes!("layout:z", "layout:x", "layout:y"),
    "start" => extended_sbase_attributes!("layout:z", "layout:x", "layout:y"),
    "end" => extended_sbase_attributes!("layout:z", "layout:x", "layout:y"),
    "basePoint1" => extended_sbase_attributes!("layout:z", "layout:x", "layout:y"),
    "basePoint2" => extended_sbase_attributes!("layout:z", "layout:x", "layout:y"),
    "boundingBox" => ALLOWED_SBASE_ATTRIBUTES,
    "curve" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfCurveSegments" => ALLOWED_SBASE_ATTRIBUTES,
    "lineSegment" => ALLOWED_SBASE_ATTRIBUTES,
    "cubicBezier" => ALLOWED_SBASE_ATTRIBUTES,
    "curveSegment" => extended_sbase_attributes!("xsi:type"),
    "dimensions" => extended_sbase_attributes!("layout:width", "layout:depth", "layout:height"),
    // fbc package
    "listOfObjectives" => extended_sbase_attributes!("fbc:activeObjective"),
    "listOfGeneProducts" => ALLOWED_SBASE_ATTRIBUTES,
    "objective" => extended_sbase_attributes!("fbc:id", "fbc:type", "fbc:name"),
    "listOfFluxObjectives" => ALLOWED_SBASE_ATTRIBUTES,
    "fluxObjective" => extended_sbase_attributes!("fbc:reaction", "fbc:coefficient"),
    "geneProductAssociation" => extended_sbase_attributes!("fbc:id", "fbc:name"),
    "geneProductRef" => extended_sbase_attributes!("fbc:id", "fbc:geneProduct"),
    "and" => ALLOWED_SBASE_ATTRIBUTES,
    "or" => ALLOWED_SBASE_ATTRIBUTES,
    "geneProduct" => extended_sbase_attributes!("fbc:id", "fbc:label", "fbc:name", "fbc:associatedSpecies"),
    //qual package
    "qualitativeSpecies" => extended_sbase_attributes!("qual:id", "qual:name", "qual:compartment", "qual:constant", "qual:initialLevel", "qual:maxLevel"),
    "listOfQualitativeSpecies" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfTransitions" => ALLOWED_SBASE_ATTRIBUTES,
    "transition" => ALLOWED_SBASE_ATTRIBUTES,
    "listOfInputs" => ALLOWED_SBASE_ATTRIBUTES,
    "input" => extended_sbase_attributes!("qual:id", "qual:name", "qual:sign", "qual:qualitativeSpecies", "qual:transitionEffect", "qual:thresholdLevel"),
    "output" => extended_sbase_attributes!("qual:id", "qual:name", "qual:qualitativeSpecies", "qual:transitionEffect", "qual:outputLevel"),
    "defaultTerm" => extended_sbase_attributes!("qual:resultLevel"),
    "functionTerm" => extended_sbase_attributes!("qual:resultLevel"),
};

// <String> attributes are omitted as their value is always considered valid nevertheless the actual value
pub const ATTRIBUTE_TYPES: Map<&str, Map<&str, &str>> = phf_map! {
    "sbml" => phf_map! { "level" => "positive_int", "version" => "positive_int"},
    "model" => phf_map! { "fbc:strict" => "boolean" },
    "unit" => phf_map! { "exponent" => "double", "scale" => "int", "multiplier" => "double"},
    "compartment" => phf_map! { "spatialDimensions" => "double", "size" => "double", "constant" => "boolean"},
    "species" => phf_map! { "initialAmount" => "double", "initialConcentration" => "double", "hasOnlySubstanceUnits" => "boolean", "boundaryCondition" => "boolean", "constant" => "boolean", "charge" => "int"},
    "parameter" => phf_map! { "value" => "double", "constant" => "boolean"},
    "reaction" => phf_map! { "reversible" => "boolean", "lowerFluxBound" => "sid", "upperFluxBound" => "sid"},
    "speciesReference" => phf_map! { "stoichiometry" => "double", "constant" => "boolean"},
    "localParameter" => phf_map! { "value" => "double"},
    "event" => phf_map! { "useValuesFromTriggerTime" => "boolean" },
    "trigger" => phf_map! { "initialValue" => "boolean", "persistent" => "boolean" },
    //fbc package
    "objective" => phf_map! { "fbc:id" => "sid", "fbc:type" => "fbc_type" },
    "listOfObjectives" => phf_map! { "fbc:activeObjective" => "sid" },
    "fluxObjective" => phf_map! { "fbc:reaction" => "sid", "fbc:coefficient" => "double" },
    "geneProductAssociation" => phf_map! {"fbc:id" => "sid"},
    "geneProductRef" => phf_map! {"fbc:id" => "sid", "fbc:geneProduct" => "sid"},
    "geneProduct" => phf_map!("fbc:id" => "sid", "fbc:geneProduct" => "sid"),
    //qual package
    "qualitativeSpecies" => phf_map!("qual:id" => "sid", "qual:compartment" => "sid", "qual:constant" => "boolean", "qual:initialLevel" => "positive_int", "qual:maxLevel" => "positive_int"),
    "input" => phf_map!("qual:id" => "sid", "qual:sign" => "sign", "qual:qualitativeSpecies" => "sid", "qual:transitionEffect" => "input_effect", "qual:thresholdLevel" => "positive_int"),
    "output" => phf_map!("qual:id" => "sid", "qual:qualitativeSpecies" => "sid", "qual:transitionEffect" => "output_effect", "qual:outputLevel" => "positive_int"),
    "defaultTerm" => phf_map!("qual:resultLevel" => "positive_int"),
    "functionTerm" => phf_map!("qual:resultLevel" => "positive_int"),
    //layout package
    "position" => phf_map! { "layout:x" => "double", "layout:y" => "double", "layout:z" => "double" },
    "dimensions" => phf_map! { "layout:width" => "double", "layout:height" => "double", "layout:depth" => "double" },
};

pub const KNOWN_DEFAULT_PREFIX: Map<&str, Namespace> = phf_map! {
    "" => NS_SBML_CORE,
    "layout" => NS_LAYOUT,
    "fbc" => NS_FBC,
    "qual" => NS_QUAL
};

/// Retrieves namespace information for a given default prefix. Note that in actual SBML files,
/// packages can use different namespace prefixes as well.
pub fn namespace_for_prefix(prefix: &str) -> Namespace {
    KNOWN_DEFAULT_PREFIX
        .get(prefix)
        .expect("Default prefix not found")
        .clone()
}

pub const REQUIRED_ATTRIBUTES: Map<&str, &[&str]> = phf_map! {
    "sbml" => &["level", "version"],
    "model" => &["fbc:strict"],
    "listOfFunctionDefinitions" => &[],
    "functionDefinition" => &["id"],
    "listOfUnitDefinitions" => &[],
    "unitDefinition" => &["id"],
    "listOfUnits" => &[],
    "unit" => &["kind", "exponent", "scale", "multiplier"],
    "listOfCompartments" => &[],
    "compartment" => &["id", "constant"],
    "listOfSpecies" => &[],
    "species" => &["id", "compartment", "hasOnlySubstanceUnits", "boundaryCondition", "constant"],
    "listOfParameters" => &[],
    "parameter" => &["id", "constant"],
    "listOfInitialAssignments" => &[],
    "initialAssignment" => &["symbol"],
    "listOfRules" => &[],
    "algebraicRule" => &[],
    "assignmentRule" => &["variable"],
    "rateRule" => &["variable"],
    "listOfConstraints" => &[],
    "constraint" => &[],
    "listOfReactions" => &[],
    "reaction" => &["id", "reversible"],
    "listOfReactants" => &[],
    "listOfProducts" => &[],
    "speciesReference" => &["constant", "species"],
    "listOfModifiers" => &[],
    "modifierSpeciesReference" => &["species"],
    "kineticLaw" => &[],
    "listOfLocalParameters" => &[],
    "localParameter" => &["id"],
    "listOfEvents" => &[],
    "event" => &["useValuesFromTriggerTime"],
    "trigger" => &["initialValue", "persistent"],
    "priority" => &[],
    "delay" => &[],
    "listOfEventAssignments" => &[],
    "eventAssignment" => &["variable"],
    //layout package
    "layout" => &["layout:id"],
    "listOfLayouts" => &[],
    "graphicalObject" => &["layout:id"],
    "compartmentGlyph" => &["layout:id"],
    "speciesGlyph" => &["layout:id"],
    "reactionGlyph" => &["layout:id"],
    "generalGlyph" => &["layout:id"],
    "textGlyph" => &["layout:id"],
    "speciesReferenceGlyph" => &["layout:id", "layout:speciesGlyph"],
    "referenceGlyph" => &["layout:id", "layout:glyph"],
    "position" => &["layout:x", "layout:y"],
    "start" => &["layout:x", "layout:y"],
    "end" => &["layout:x", "layout:y"],
    "basePoint1" => &["layout:x", "layout:y"],
    "basePoint2" => &["layout:x", "layout:y"],
    "dimensions" => &["layout:width", "layout:height"],
    //fbc package
    "objective" => &["fbc:id", "fbc:type"],
    "fluxObjective" => &["fbc:reaction", "fbc:coefficient"],
    "geneProductRef" => &["fbc:geneProduct"],
    "geneProduct" => &["fbc:id", "fbc:label"],
    //qual package
    "qualitativeSpecies" => &["qual:id", "qual:compartment", "qual:constant"],
    "input" => &["qual:qualitativeSpecies", "qual:transitionEffect"],
    "output" => &["qual:qualitativeSpecies", "qual:transitionEffect"],
    "defaultTerm" => &["qual:resultLevel"],
    "functionTerm" => &["qual:resultLevel"],
};

pub const REQUIRED_CHILDREN: Map<&str, &[&str]> = phf_map! {
    "layout" => &["dimensions"],
    "listOfLayouts" => &["layout"],
    "listOfCompartmentGlyphs" => &["compartmentGlyph"],
    "listOfSpeciesGlyphs" => &["speciesGlyph"],
    "listOfReactionGlyphs" => &["reactionGlyph"],
    "listOfTextGlyphs" => &["textGlyph"],
    "reactionGlyph" => &["listOfSpeciesReferenceGlyphs"],
    "listOfSpeciesReferenceGlyphs" => &["speciesReferenceGlyph"],
    "listOfReferenceGlyphs" => &["referenceGlyph"],
    "listOfSubGlyphs" => &["graphicalObject"],
    "boundingBox" => &["position", "dimensions"],
    "curve" => &["listOfCurveSegments"],
    "listOfCurveSegments" => &["curveSegment"],
    "curveSegment" => &["start", "end"],
    "lineSegment" => &["start", "end"],
    "cubicBezier" => &["start", "basePoint1", "basePoint2", "end"],
    //fbc package
    "listOfObjectives" => &["objective"],
    "listOfGeneProducts" => &["geneProduct"],
    "objective" => &["listOfFluxObjectives"],
    //qual package
    "listOfTransitions" => &["transition"],
    "listOfQualitativeSpecies" => &["qualitativeSpecies"],
    "transition" => &["listOfFunctionTerms"],
    "functionTerms" => &["math"],
};

pub const ALLOWED_CHILDREN: Map<&str, &[&str]> = phf_map! {
    "sbml" => extended_sbase_children!("model"),
    "model" => extended_sbase_children!("listOfFunctionDefinitions", "listOfUnitDefinitions", "listOfCompartments", "listOfSpecies", "listOfParameters", "listOfInitialAssignments", "listOfRules", "listOfConstraints", "listOfReactions", "listOfEvents", "listOfLayouts", "listOfGeneProducts", "listOfObjectives", "listOfTransitions", "listOfQualitativeSpecies"),
    "listOfFunctionDefinitions" => extended_sbase_children!("functionDefinition"),
    "functionDefinition" => extended_sbase_children!("math"),
    "listOfUnitDefinitions" => extended_sbase_children!("unitDefinition"),
    "unitDefinition" => extended_sbase_children!("listOfUnits"),
    "listOfUnits" => extended_sbase_children!("unit"),
    "unit" => ALLOWED_SBASE_CHILDREN,
    "listOfCompartments" => extended_sbase_children!("compartment"),
    "compartment" => ALLOWED_SBASE_CHILDREN,
    "listOfSpecies" => extended_sbase_children!("species"),
    "species" => ALLOWED_SBASE_CHILDREN,
    "listOfParameters" => extended_sbase_children!("parameter"),
    "parameter" => ALLOWED_SBASE_CHILDREN,
    "listOfInitialAssignments" => extended_sbase_children!("initialAssignment"),
    "initialAssignment" => extended_sbase_children!("math"),
    "listOfRules" => extended_sbase_children!("algebraicRule", "assignmentRule", "rateRule"),
    "algebraicRule" => extended_sbase_children!("math"),
    "assignmentRule" => extended_sbase_children!("math"),
    "rateRule" => extended_sbase_children!("math"),
    "listOfConstraints" => extended_sbase_children!("constraint"),
    "constraint" => extended_sbase_children!("math", "message"),
    "listOfReactions" => extended_sbase_children!("reaction"),
    "reaction" => extended_sbase_children!("listOfReactants", "listOfProducts", "listOfModifiers", "kineticLaw", "geneProductAssociation"),
    "listOfReactants" => extended_sbase_children!("speciesReference"),
    "listOfProducts" => extended_sbase_children!("speciesReference"),
    "speciesReference" => ALLOWED_SBASE_CHILDREN,
    "listOfModifiers" => extended_sbase_children!("modifierSpeciesReference"),
    "modifierSpeciesReference" => ALLOWED_SBASE_CHILDREN,
    "kineticLaw" => extended_sbase_children!("math", "listOfLocalParameters"),
    "listOfLocalParameters" => extended_sbase_children!("localParameter"),
    "localParameter" => ALLOWED_SBASE_CHILDREN,
    "listOfEvents" => extended_sbase_children!("event"),
    "event" => extended_sbase_children!("trigger", "priority", "delay", "listOfEventAssignments"),
    "trigger" => extended_sbase_children!("math"),
    "priority" => extended_sbase_children!("math"),
    "delay" => extended_sbase_children!("math"),
    "listOfEventAssignments" => extended_sbase_children!("eventAssignment"),
    "eventAssignment" => extended_sbase_children!("math"),
    //layout package
    "layout" => extended_sbase_children!("listOfCompartmentGlyphs", "listOfSpeciesGlyphs", "listOfReactionGlyphs", "listOfTextGlyphs", "listOfAdditionalGraphicalObjects", "dimension"),
    "listOfLayouts" => extended_sbase_children!("layout"),
    "listOfCompartmentGlyphs" => extended_sbase_children!("compartmentGlyph"),
    "listOfSpeciesGlyphs" => extended_sbase_children!("speciesGlyph"),
    "listOfReactionGlyphs" => extended_sbase_children!("reactionGlyph"),
    "listOfAdditionalGraphicalObjects" => extended_sbase_children!("graphicalObjects", "generalGlyph"),
    "listOfTextGlyphs" => extended_sbase_children!("boundingBox", "textGlyph"),
    "graphicalObject" => extended_sbase_children!("boundingBox"),
    "compartmentGlyph" => extended_sbase_children!("boundingBox"),
    "speciesGlyph" => extended_sbase_children!("boundingBox"),
    "reactionGlyph" => extended_sbase_children!("boundingBox", "curve", "listOfSpeciesReferenceGlyphs"),
    "listOfSpeciesReferenceGlyphs" => extended_sbase_children!("speciesReferenceGlyph", "boundingBox"),
    "generalGlyph" => extended_sbase_children!("curve", "listOfReferenceGlyphs", "listOfSubGlyphs", "boundingBox"),
    "listOfReferenceGlyphs" => extended_sbase_children!("referenceGlyph"),
    "textGlyph" => extended_sbase_children!("boundingBox"),
    "speciesReferenceGlyph" => extended_sbase_children!("curve", "boundingBox"),
    "referenceGlyph" => extended_sbase_children!("boundingBox"),
    "listOfSubGlyphs" => extended_sbase_children!("graphicalObject"),
    "position" => ALLOWED_SBASE_CHILDREN,
    "start" => ALLOWED_SBASE_CHILDREN,
    "end" => ALLOWED_SBASE_CHILDREN,
    "basePoint1" => ALLOWED_SBASE_CHILDREN,
    "basePoint2" => ALLOWED_SBASE_CHILDREN,
    "boundingBox" => extended_sbase_children!("point", "dimensions"),
    "curve" => extended_sbase_children!("listOfCurveSegments"),
    "listOfCurveSegments" => extended_sbase_children!("curveSegment"),
    "curveSegment" => extended_sbase_children!("start", "basePoint1", "basePoint2", "end"),
    "dimensions" => ALLOWED_SBASE_CHILDREN,
    //fbc package
    "objective" => extended_sbase_children!("listOfFluxObjectives"),
    "listOfFluxObjectives" => extended_sbase_children!("fluxObjective"),
    "listOfObjectives" => extended_sbase_children!("objective"),
    "listOfGeneProducts" => extended_sbase_children!("geneProduct"),
    "fluxObjective" => ALLOWED_SBASE_CHILDREN,
    "geneProductAssociation" => extended_sbase_children!("geneProductRef", "and", "or"),
    "geneProductRef" => ALLOWED_SBASE_CHILDREN,
    "and" => extended_sbase_children!("and", "or", "geneProductRef"),
    "or" => extended_sbase_children!("and", "or", "geneProductRef"),
    "geneProduct" => ALLOWED_SBASE_CHILDREN,
    //qual package
    "listOfTransitions" => extended_sbase_children!("transitions"),
    "listOfQualitativeSpecies" => extended_sbase_children!("qualitativeSpecies"),
    "qualitativeSpecies" => ALLOWED_SBASE_CHILDREN,
    "transition" => extended_sbase_children!("listOfInputs", "listOfOutputs", "listOfFunctionTerms"),
    "input" => ALLOWED_SBASE_CHILDREN,
    "output" => ALLOWED_SBASE_CHILDREN,
    "defaultTerm" => ALLOWED_SBASE_CHILDREN,
    "functionTerm" => extended_sbase_children!("math"),
};

/// This lists the (optional) child elements that must be unique in each SBML Core element.
///
/// For the most part, this is the same as [ALLOWED_CHILDREN], except for lists, where the item
/// elements can obviously repeat.
pub const UNIQUE_CHILDREN: Map<&str, &[&str]> = phf_map! {
    "sbml" => extended_sbase_children!("model"),
    "model" => extended_sbase_children!("listOfFunctionDefinitions", "listOfUnitDefinitions", "listOfCompartments", "listOfSpecies", "listOfParameters", "listOfInitialAssignments", "listOfRules", "listOfConstraints", "listOfReactions", "listOfEvents", "listOfTransitions", "listOfQualitativeSpecies"),
    "listOfFunctionDefinitions" => extended_sbase_children!(),
    "functionDefinition" => extended_sbase_children!("math"),
    "listOfUnitDefinitions" => extended_sbase_children!(),
    "unitDefinition" => extended_sbase_children!("listOfUnits"),
    "listOfUnits" => extended_sbase_children!(),
    "unit" => extended_sbase_children!(),
    "listOfCompartments" => extended_sbase_children!(),
    "compartment" => extended_sbase_children!(),
    "listOfSpecies" => extended_sbase_children!(),
    "species" => extended_sbase_children!(),
    "listOfParameters" => extended_sbase_children!(),
    "parameter" => extended_sbase_children!(),
    "listOfInitialAssignments" => extended_sbase_children!(),
    "initialAssignment" => extended_sbase_children!("math"),
    "listOfRules" => extended_sbase_children!(),
    "algebraicRule" => extended_sbase_children!("math"),
    "assignmentRule" => extended_sbase_children!("math"),
    "rateRule" => extended_sbase_children!("math"),
    "listOfConstraints" => extended_sbase_children!(),
    "constraint" => extended_sbase_children!("math", "message"),
    "listOfReactions" => extended_sbase_children!(),
    "reaction" => extended_sbase_children!("listOfReactants", "listOfProducts", "listOfModifiers", "kineticLaw", "geneProductAssociation"),
    "listOfReactants" => extended_sbase_children!(),
    "listOfProducts" => extended_sbase_children!(),
    "speciesReference" => extended_sbase_children!(),
    "listOfModifiers" => extended_sbase_children!(),
    "modifierSpeciesReference" => extended_sbase_children!(),
    "kineticLaw" => extended_sbase_children!("math", "listOfLocalParameters"),
    "listOfLocalParameters" => extended_sbase_children!(),
    "localParameter" => extended_sbase_children!(),
    "listOfEvents" => extended_sbase_children!(),
    "event" => extended_sbase_children!("trigger", "priority", "delay", "listOfEventAssignments"),
    "trigger" => extended_sbase_children!("math"),
    "priority" => extended_sbase_children!("math"),
    "delay" => extended_sbase_children!("math"),
    "listOfEventAssignments" => extended_sbase_children!(),
    "eventAssignment" => extended_sbase_children!("math"),
    //layout package
    "layout" => extended_sbase_children!("dimensions", "listOfCompartmentGlyphs", "listOfSpeciesGlyphs", "listOfReactionGlyphs", "listOfTextGlyphs", "listOfAdditionalGraphicalObjects"),
    "listOfLayouts" => extended_sbase_children!(),
    "listOfCompartmentGlyphs" => ALLOWED_SBASE_CHILDREN,
    "listOfSpeciesGlyphs" => ALLOWED_SBASE_CHILDREN,
    "listOfReactionGlyphs" => ALLOWED_SBASE_CHILDREN,
    "listOfAdditionalGraphicalObjects" => ALLOWED_SBASE_CHILDREN,
    "listOfTextGlyphs" => ALLOWED_SBASE_CHILDREN,
    "graphicalObject" => extended_sbase_children!("boundingBox"),
    "compartmentGlyph" => extended_sbase_children!("boundingBox"),
    "speciesGlyph" => extended_sbase_children!("boundingBox"),
    "generalGlyph" => extended_sbase_children!("boundingBox", "curve", "listOfReferenceGlyphs", "listOfSubGlyphs"),
    "speciesReferenceGlyph" => extended_sbase_children!("boundingBox", "curve"),
    "referenceGlyph" => extended_sbase_children!("boundingBox", "curve"),
    "reactionGlyph" => extended_sbase_children!("boundingBox", "cure", "listOfSpeciesReferenceGlyphs"),
    "textGlyph" => extended_sbase_children!("boundingBox"),
    "listOfSpeciesReferenceGlyphs" => ALLOWED_SBASE_CHILDREN,
    "listOfReferenceGlyphs" => ALLOWED_SBASE_CHILDREN,
    "listOfSubGlyphs" => ALLOWED_SBASE_CHILDREN,
    "position" => ALLOWED_SBASE_CHILDREN,
    "start" => ALLOWED_SBASE_CHILDREN,
    "end" => ALLOWED_SBASE_CHILDREN,
    "basePoint1" => ALLOWED_SBASE_CHILDREN,
    "basePoint2" => ALLOWED_SBASE_CHILDREN,
    "boundingBox" => extended_sbase_children!("point", "dimensions"),
    "curve" => extended_sbase_children!("listOfCurveSegments"),
    "listOfCurveSegments" => extended_sbase_children!("curveSegments"),
    "curveSegment" => extended_sbase_children!("start", "end", "basePoint1", "basePoint2"),
    "dimensions" => ALLOWED_SBASE_CHILDREN,
    //fbc package
    "objective" => extended_sbase_children!("listOfFluxObjectives"),
    "listOfObjectives" => extended_sbase_children!("listOfObjectives"),
    "listOfFluxObjectives" => ALLOWED_SBASE_CHILDREN,
    "geneProductAssociation" => extended_sbase_children!("geneProductRef", "and", "or"),
    "geneProductRef" => ALLOWED_SBASE_CHILDREN,
    "and" => ALLOWED_SBASE_CHILDREN,
    "or" => ALLOWED_SBASE_CHILDREN,
    "geneProduct" => ALLOWED_SBASE_CHILDREN,
    "listOfGeneProducts" => ALLOWED_SBASE_CHILDREN,
    "fluxObjective" => ALLOWED_SBASE_CHILDREN,
    //qual package
    "listOfTransitions" => ALLOWED_SBASE_CHILDREN,
    "listOfQualitativeSpecies" => ALLOWED_SBASE_CHILDREN,
    "qualitativeSpecies" => ALLOWED_SBASE_CHILDREN,
    "transition" => extended_sbase_children!("listOfInputs", "listOfOutputs", "listOfFunctionTerms"),
    "input" => ALLOWED_SBASE_CHILDREN,
    "output" => ALLOWED_SBASE_CHILDREN,
    "defaultTerm" => ALLOWED_SBASE_CHILDREN,
    "functionTerm" => extended_sbase_children!("math")
};

// There are no required children in SBML core level 3 version 1

pub const MATHML_ALLOWED_CHILDREN: Map<&str, &[&str]> = phf_map! {
    "math" => &["abs", "and", "annotation", "annotation-xml", "apply", "arccosh", "arccos", "arccoth",
                "arccot", "arccsch", "arccsc", "arcsech", "arcsec", "arcsinh", "arcsin", "arctanh",
                "arctan", "bvar", "ceiling", "ci", "cn", "cosh", "cos", "coth", "cot", "csch", "csc",
                "csymbol", "degree", "divide", "eq", "exponentiale", "exp", "factorial", "false",
                "floor", "geq", "gt", "implies", "infinity", "lambda", "leq", "ln", "logbase", "log",
                "lt", "max", "min", "minus", "neq", "notanumber", "not", "or", "otherwise", "piecewise",
                "piece", "pi", "plus", "power", "quotient", "rem", "root", "sech", "sec", "semantics",
                "sep", "sinh", "sin", "tanh", "tan", "times", "true", "xor"]
};

pub const MATHML_ALLOWED_CHILDREN_BY_ATTR: Map<&str, &[&str]> = phf_map! {
    "encoding" => &["csymbol", "annotation", "annotation-xml"],
    "definitionURL" => &["ci", "csymbol", "semantics"],
    "type" => &["cn"],
    "units" => &["cn"]
};

pub const MATHML_ALLOWED_DEFINITION_URLS: &[&str] = &[
    "http://www.sbml.org/sbml/symbols/time",
    "http://www.sbml.org/sbml/symbols/delay",
    "http://www.sbml.org/sbml/symbols/avogadro",
    "http://www.sbml.org/sbml/symbols/rateOf",
];

pub const MATHML_ALLOWED_TYPES: &[&str] = &["e-notation", "real", "integer", "rational"];

// source: https://www.w3.org/TR/MathML2/chapter4.html#contm.funopqual
pub const MATHML_UNARY_OPERATORS: &[&str] = &[
    "factorial",
    "minus",
    "abs",
    "conjugate",
    "arg",
    "real",
    "imaginary",
    "floor",
    "ceiling",
    "not",
    "inverse",
    "ident",
    "domain",
    "codomain",
    "image",
    "sin",
    "cos",
    "tan",
    "sec",
    "csc",
    "cot",
    "sinh",
    "cosh",
    "tanh",
    "sech",
    "csch",
    "coth",
    "arcsin",
    "arccos",
    "arctan",
    "arccosh",
    "arccot",
    "arccoth",
    "arccsc",
    "arccsch",
    "arcsec",
    "arcsech",
    "arcsinh",
    "arctanh",
    "exp",
    "ln",
    "log",
    "determinant",
    "transpose",
    "divergence",
    "grad",
    "curl",
    "laplacian",
    "card",
];

// source: https://www.w3.org/TR/MathML2/chapter4.html#contm.funopqual
pub const MATHML_BINARY_OPERATORS: &[&str] = &[
    "quotient",
    "divide",
    "minus",
    "power",
    "rem",
    "root", // special operator of which one argument (degree) is by default 2 and therefore one argument is sufficient
    "implies",
    "equivalent",
    "approx",
    "setdiff",
    "vectorproduct",
    "scalarproduct",
    "outerproduct",
];

/*

   This is currently unused, but will become relevant once we start implementing
   the MathML abstraction.

   // source: https://www.w3.org/TR/MathML2/chapter4.html#contm.funopqual
   pub const MATHML_NARY_OPERATORS: &[&str] = &[
       "plus",
       "times",
       "max",
       "min",
       "gcd",
       "lcm",
       "mean",
       "sdev",
       "variance",
       "median",
       "mode",
       "union",
       "intersect",
       "cartesianproduct",
       "selector",
       "and",
       "or",
       "xor",
       "eq",
       "neq",
       "leq",
       "lt",
       "geq",
       "gt",
   ];

*/
